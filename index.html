<!DOCTYPE html>
<html>
<head>
    <title>å¸äº†ä¸ªå¸ - åŠ å¯†è´§å¸æ¶ˆé™¤æ¸¸æˆ</title>
    <style>
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        #game-container {
            width: 100%;
            max-width: 420px;
            margin: 0 auto;
            position: relative;
        }
        #game-board {
            width: 100%;
            height: 500px;
            background: #ffffff;
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .tile {
            position: absolute;
            width: 64px;
            height: 64px;
            border-radius: 12px;
            background-size: 60%;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            background-color: #ffffff;
            border: 2px solid #e9ecef;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #343a40;
            font-size: 10px;
            text-align: center;
            padding-top: 40px;
            box-sizing: border-box;
        }
        .tile:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }
        .tile.selected {
            transform: scale(1.12);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.8);
            border-color: #ffc107;
        }
        #slot-bar {
            height: 80px;
            background: #e9ecef;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 0 10px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        .slot {
            width: 54px;
            height: 54px;
            background: #ffffff;
            border-radius: 8px;
            border: 2px dashed #adb5bd;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 9px;
            text-align: center;
            padding-top: 40px;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        .slot.filled {
            border: 2px solid #495057;
            animation: pulse 0.5s;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        #controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        button {
            padding: 12px 25px;
            background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        button:active {
            transform: translateY(0);
        }
        #level-display {
            font-size: 28px;
            margin: 15px 0;
            color: #495057;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        #score-display {
            font-size: 20px;
            margin: 10px 0;
            color: #4dabf7;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            animation: modalAppear 0.3s;
        }
        @keyframes modalAppear {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal h2 {
            margin-top: 0;
            color: #4dabf7;
        }
        .modal button {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>ğŸ¶ å¸äº†ä¸ªå¸ ğŸ¶</h1>
    <div id="level-display">ç¬¬1å…³</div>
    <div id="score-display">åˆ†æ•°: 0</div>
    <div id="game-container">
        <div id="game-board"></div>
        <div id="slot-bar">
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
            <div class="slot"></div>
        </div>
    </div>
    <div id="controls">
        <button id="restart">é‡æ–°å¼€å§‹</button>
        <button id="hint">æç¤º (3)</button>
    </div>

    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2>ğŸ‰ æ­å–œè¿‡å…³! ğŸ‰</h2>
            <p>ä½ æˆåŠŸé€šè¿‡äº†ç¬¬<span id="current-level">1</span>å…³ï¼</p>
            <p>è·å¾—åˆ†æ•°: <span id="level-score">100</span></p>
            <button id="next-level">ä¸‹ä¸€å…³</button>
        </div>
    </div>

    <div id="lose-modal" class="modal">
        <div class="modal-content">
            <h2>ğŸ˜­ æ¸¸æˆç»“æŸ ğŸ˜­</h2>
            <p>ä½ åœ¨ç¬¬<span id="failed-level">1</span>å…³å¤±è´¥äº†</p>
            <p>æœ€ç»ˆåˆ†æ•°: <span id="final-score">0</span></p>
            <button id="try-again">å†è¯•ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // åŠ å¯†è´§å¸æ•°æ®
        const cryptoData = [
            { name: 'æ¯”ç‰¹å¸', symbol: 'BTC', color: '#f7931a' },
            { name: 'ä»¥å¤ªåŠ', symbol: 'ETH', color: '#627eea' },
            { name: 'ç‹—ç‹—å¸', symbol: 'DOGE', color: '#c2a633' },
            { name: 'æŸ´çŠ¬å¸', symbol: 'SHIB', color: '#f00500' },
            { name: 'ç´¢æ‹‰çº³', symbol: 'SOL', color: '#00ffbd' },
            { name: 'ç‘æ³¢å¸', symbol: 'XRP', color: '#27a2db' },
            { name: 'è‰¾è¾¾å¸', symbol: 'ADA', color: '#0033ad' },
            { name: 'æ³¢å¡å¸', symbol: 'DOT', color: '#e6007a' },
            { name: 'è±ç‰¹å¸', symbol: 'LTC', color: '#345d9d' },
            { name: 'é“¾é“¾æ¥', symbol: 'LINK', color: '#2a5ada' },
            { name: 'æ’æ˜Ÿå¸', symbol: 'XLM', color: '#000000' },
            { name: 'æ³°è¾¾å¸', symbol: 'USDT', color: '#26a17b' }
        ];

        // æ¸¸æˆçŠ¶æ€
        const state = {
            level: 1,
            score: 0,
            tiles: [],
            selectedTiles: [],
            slots: Array(7).fill(null),
            blocked: false,
            hintCount: 3,
            tileCount: 0
        };

        // DOMå…ƒç´ 
        const gameBoard = document.getElementById('game-board');
        const slotElements = document.querySelectorAll('.slot');
        const levelDisplay = document.getElementById('level-display');
        const scoreDisplay = document.getElementById('score-display');
        const restartButton = document.getElementById('restart');
        const hintButton = document.getElementById('hint');
        const winModal = document.getElementById('win-modal');
        const loseModal = document.getElementById('lose-modal');
        const currentLevelSpan = document.getElementById('current-level');
        const levelScoreSpan = document.getElementById('level-score');
        const failedLevelSpan = document.getElementById('failed-level');
        const finalScoreSpan = document.getElementById('final-score');
        const nextLevelButton = document.getElementById('next-level');
        const tryAgainButton = document.getElementById('try-again');

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            clearBoard();
            createTiles();
            renderTiles();
            updateSlots();
            updateUI();
        }

        // æ¸…ç©ºæ¸¸æˆæ¿
        function clearBoard() {
            gameBoard.innerHTML = '';
            state.tiles = [];
            state.selectedTiles = [];
            state.slots = Array(7).fill(null);
            state.blocked = false;
            state.tileCount = 0;
        }

        // åˆ›å»ºæ–¹å—
        function createTiles() {
            const baseCount = 15;
            const levelMultiplier = 1 + (state.level - 1) * 0.3;
            const tileCount = Math.floor(baseCount * levelMultiplier);
            state.tileCount = tileCount;
            
            // æ ¹æ®å…³å¡å†³å®šä½¿ç”¨å¤šå°‘ç§åŠ å¯†è´§å¸
            const cryptoCount = Math.min(4 + Math.floor(state.level / 3), cryptoData.length);
            const usedCryptos = getRandomCryptos(cryptoCount);
            
            // åˆ›å»ºå¤šå±‚æ–¹å—
            for (let i = 0; i < tileCount; i++) {
                const crypto = usedCryptos[Math.floor(Math.random() * usedCryptos.length)];
                const layer = Math.floor(Math.random() * 3); // 0-2å±‚
                
                // éšæœºä½ç½®ï¼Œç¡®ä¿ä¸ä¼šå®Œå…¨é‡å 
                let x, y, overlapping;
                let attempts = 0;
                do {
                    overlapping = false;
                    x = 20 + Math.random() * (gameBoard.offsetWidth - 100);
                    y = 20 + Math.random() * (gameBoard.offsetHeight - 100);
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–æ–¹å—é‡å è¿‡å¤š
                    for (const tile of state.tiles) {
                        if (tile.layer === layer && 
                            Math.abs(tile.x - x) < 50 && 
                            Math.abs(tile.y - y) < 50) {
                            overlapping = true;
                            break;
                        }
                    }
                    attempts++;
                } while (overlapping && attempts < 20);
                
                state.tiles.push({
                    id: i,
                    crypto,
                    layer,
                    x,
                    y,
                    visible: true,
                    element: null
                });
            }
        }

        // è·å–éšæœºçš„åŠ å¯†è´§å¸
        function getRandomCryptos(count) {
            const shuffled = [...cryptoData].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        // æ¸²æŸ“æ–¹å—
        function renderTiles() {
            // æŒ‰å±‚æ’åºï¼Œç¡®ä¿ä¸Šå±‚è¦†ç›–ä¸‹å±‚
            state.tiles.sort((a, b) => a.layer - b.layer);
            
            state.tiles.forEach(tile => {
                if (!tile.visible) return;
                
                const tileElement = document.createElement('div');
                tileElement.className = 'tile';
                tileElement.style.left = `${tile.x}px`;
                tileElement.style.top = `${tile.y}px`;
                tileElement.style.backgroundColor = tile.crypto.color;
                tileElement.textContent = tile.crypto.symbol;
                tileElement.dataset.id = tile.id;
                tileElement.title = tile.crypto.name;
                
                tileElement.addEventListener('click', () => handleTileClick(tile));
                
                gameBoard.appendChild(tileElement);
                tile.element = tileElement;
            });
        }

        // å¤„ç†æ–¹å—ç‚¹å‡»
        function handleTileClick(tile) {
            if (state.blocked || !tile.visible || state.slots.every(slot => slot !== null)) return;
            
            // æ·»åŠ åˆ°é€‰ä¸­åˆ—è¡¨
            state.selectedTiles.push(tile);
            tile.element.classList.add('selected');
            
            // æ£€æŸ¥æ˜¯å¦æœ‰3ä¸ªç›¸åŒçš„
            checkMatches();
        }

        // æ£€æŸ¥åŒ¹é…
        function checkMatches() {
            // æŒ‰ç±»å‹åˆ†ç»„
            const cryptoGroups = {};
            state.selectedTiles.forEach(tile => {
                const symbol = tile.crypto.symbol;
                if (!cryptoGroups[symbol]) cryptoGroups[symbol] = [];
                cryptoGroups[symbol].push(tile);
            });
            
            // æ£€æŸ¥æ˜¯å¦æœ‰3ä¸ªç›¸åŒçš„
            let matched = false;
            for (const symbol in cryptoGroups) {
                if (cryptoGroups[symbol].length >= 3) {
                    matched = true;
                    // è®¡ç®—å¾—åˆ† (åŸºç¡€åˆ† + è¿å‡»åŠ æˆ)
                    const baseScore = 10 * state.level;
                    const comboBonus = (cryptoGroups[symbol].length - 3) * 5;
                    const score = baseScore + comboBonus;
                    state.score += score;
                    
                    // æ¶ˆé™¤åŒ¹é…çš„æ–¹å—
                    cryptoGroups[symbol].forEach(tile => {
                        tile.visible = false;
                        if (tile.element) {
                            tile.element.style.transform = 'scale(1.2)';
                            tile.element.style.opacity = '0';
                            setTimeout(() => {
                                tile.element.remove();
                            }, 300);
                        }
                    });
                    
                    // ä»é€‰ä¸­åˆ—è¡¨ä¸­ç§»é™¤
                    state.selectedTiles = state.selectedTiles.filter(t => t.crypto.symbol !== symbol);
                    
                    // æ£€æŸ¥æ˜¯å¦èƒœåˆ©
                    if (state.tiles.every(tile => !tile.visible)) {
                        setTimeout(() => {
                            showWinModal();
                        }, 800);
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰åŒ¹é…ï¼Œæ·»åŠ åˆ°æ§½ä½
            if (!matched) {
                addToSlot();
            }
            
            updateUI();
        }

        // æ·»åŠ åˆ°æ§½ä½
        function addToSlot() {
            const emptySlotIndex = state.slots.findIndex(slot => slot === null);
            if (emptySlotIndex === -1) return;
            
            const tile = state.selectedTiles.pop();
            state.slots[emptySlotIndex] = tile;
            tile.element.classList.remove('selected');
            tile.element.remove();
            
            // æ›´æ–°æ§½ä½æ˜¾ç¤º
            const slotElement = slotElements[emptySlotIndex];
            slotElement.style.backgroundColor = tile.crypto.color;
            slotElement.textContent = tile.crypto.symbol;
            slotElement.title = tile.crypto.name;
            slotElement.classList.add('filled');
            
            // æ£€æŸ¥æ˜¯å¦å¤±è´¥
            if (state.slots.every(slot => slot !== null)) {
                state.blocked = true;
                setTimeout(() => {
                    showLoseModal();
                }, 500);
            }
        }

        // æ›´æ–°UIæ˜¾ç¤º
        function updateUI() {
            levelDisplay.textContent = `ç¬¬${state.level}å…³`;
            scoreDisplay.textContent = `åˆ†æ•°: ${state.score}`;
            hintButton.textContent = `æç¤º (${state.hintCount})`;
            hintButton.disabled = state.hintCount <= 0;
        }

        // æ˜¾ç¤ºèƒœåˆ©å¼¹çª—
        function showWinModal() {
            currentLevelSpan.textContent = state.level;
            levelScoreSpan.textContent = 100 * state.level;
            winModal.style.display = 'flex';
        }

        // æ˜¾ç¤ºå¤±è´¥å¼¹çª—
        function showLoseModal() {
            failedLevelSpan.textContent = state.level;
            finalScoreSpan.textContent = state.score;
            loseModal.style.display = 'flex';
        }

        // æç¤ºåŠŸèƒ½
        function useHint() {
            if (state.hintCount <= 0 || state.blocked) return;
            
            // æ‰¾å‡ºå¯ä»¥ç»„æˆ3ä¸ªçš„åŠ å¯†è´§å¸
            const visibleTiles = state.tiles.filter(tile => tile.visible);
            const cryptoCount = {};
            
            visibleTiles.forEach(tile => {
                const symbol = tile.crypto.symbol;
                cryptoCount[symbol] = (cryptoCount[symbol] || 0) + 1;
            });
            
            // æ‰¾åˆ°è‡³å°‘æœ‰3ä¸ªçš„åŠ å¯†è´§å¸
            const availableCryptos = Object.keys(cryptoCount).filter(symbol => cryptoCount[symbol] >= 3);
            if (availableCryptos.length === 0) return;
            
            const hintCrypto = availableCryptos[0];
            const hintTiles = visibleTiles.filter(tile => tile.crypto.symbol === hintCrypto).slice(0, 3);
            
            // é«˜äº®æç¤º
            hintTiles.forEach(tile => {
                if (tile.element) {
                    tile.element.style.boxShadow = '0 0 15px #ff0';
                    setTimeout(() => {
                        if (tile.element) tile.element.style.boxShadow = '';
                    }, 1000);
                }
            });
            
            state.hintCount--;
            updateUI();
        }

        // äº‹ä»¶ç›‘å¬
        restartButton.addEventListener('click', () => {
            state.level = 1;
            state.score = 0;
            state.hintCount = 3;
            initGame();
            winModal.style.display = 'none';
            loseModal.style.display = 'none';
        });

        hintButton.addEventListener('click', useHint);

        nextLevelButton.addEventListener('click', () => {
            state.level++;
            state.hintCount = Math.min(state.hintCount + 1, 5); // æ¯å…³å¢åŠ 1ä¸ªæç¤ºï¼Œæœ€å¤š5ä¸ª
            winModal.style.display = 'none';
            initGame();
        });

        tryAgainButton.addEventListener('click', () => {
            loseModal.style.display = 'none';
            initGame();
        });

        // å¼€å§‹æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
